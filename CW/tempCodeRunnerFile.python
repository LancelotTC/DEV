from time import sleep
from typing import Callable
import attrs
from threading import Thread
import atexit


# @attrs.define
# class ScheduledTask:
# 	function: Callable
# 	interval: int
# 	label: str

# 	def __hash__(self) -> int:
# 		return hash(self.function) + hash(self.interval)


# class RecurringTasks:
# 	def __init__(self):
# 		self.running = True
# 		self.functions: list[ScheduledTask] = []
# 		self.threads: list[Thread] = []
# 		self.refresh_labels: dict[ScheduledTask, str] = {}
# 		self.len_last_label: int = 0
# 		# atexit(self.stop)

# 	def add_task(self, func: Callable, interval: int, label):
# 		self.functions.append(ScheduledTask(func, interval, label))

# 	def start(self):
# 		for scheduled_task in self.functions:
# 			thread = Thread(target=self._run_function, args=(scheduled_task, ))
# 			thread.start()
# 			self.threads.append(thread)
	
# 	def _run_function(self, scheduled_task: ScheduledTask):
# 		remaining_interval = scheduled_task.interval
# 		while self.running:
# 			sleep(1)
# 			remaining_interval -= 1

# 			# I need to display in both cases because calling the function will delay the displaying otherwise,
# 			# and I can't know the label in advance unless I check twice which is ugly
# 			if remaining_interval <= 0:
# 				self.refresh_labels[scheduled_task] = f"Refreshing {scheduled_task.label}"
# 				self._display()
# 				scheduled_task.function()
# 				remaining_interval = scheduled_task.interval
# 			else:
# 				self.refresh_labels[scheduled_task] = f"Refreshing {scheduled_task.label} in {remaining_interval}s"
# 				self._display()

# 	def stop(self):
# 		self.running = False
	
# 	def _display(self):
# 		print("\r", end="")
# 		# concatenated_values = " | ".join(value for value in self.refresh_labels.values())
# 		label = " | ".join(value for value in self.refresh_labels.values())
# 		print(label, end=" "*self.len_last_label)

# 		self.len_last_label = len(label)


def func1():
	sleep(1)

def func2():
	sleep(4)


from tools import RecurringTasks

s = RecurringTasks()

atexit.register(s.stop)
s.add_task(func1, 5, "func1")
# s.add_task(func2, 3, "func2")

s.start()
